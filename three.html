<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>My first three.js app</title>
		<style>
			body { margin: 0;
            }
			canvas {
                width: 100%;
                height: 100%;
                background: -moz-linear-gradient(top,  skyblue 0%, #555555 100%); /* FF3.6-15 */
                background: -webkit-linear-gradient(top,  skyblue 0%,#555555 100%); /* Chrome10-25,Safari5.1-6 */
                background: linear-gradient(to bottom,  skyblue 0%,#555555 100%); /* W3C, IE10+, FF16+, Chrome26+, Opera12+, Safari7+ */
            }


		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/msgpack.min.js"></script>
		<script>
			var scene = new THREE.Scene();
            // scene.background = new THREE.Color('skyblue');
			var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
			var renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			var geometry = new THREE.BoxGeometry(1, 1, 1);
			var material = new THREE.MeshPhongMaterial({color: 0x00ff00,
				reflectivity: 0.5,
				shininess: Math.pow(2, 10)
			});
			var cube = new THREE.Mesh(geometry, material);
			// scene.add(cube);

			var light = new THREE.DirectionalLight(0xffffff, 0.5);
			light.position.set(5, 5, 10);
			scene.add(light);

			var ambient_light = new THREE.AmbientLight(0xffffff, 0.3);
			scene.add(ambient_light);

			var connection = new WebSocket('ws://127.0.0.1:8765');
			connection.binaryType = "arraybuffer";
			connection.onopen = function () {
				connection.send(msgpack.encode(100000));
			};

			function add_pointcloud(command) {
				let geom = new THREE.BufferGeometry();
				geom.addAttribute('position', new THREE.BufferAttribute(command.points, 3));

				if (command.channels !== undefined) {
					if (command.channels.rgb !== undefined) {
						geom.addAttribute('color', new THREE.BufferAttribute(command.channels.rgb, 3));
					}
				}

				let object = new THREE.Points(geom, new THREE.PointsMaterial({
					size: 0.001,
					vertexColors: THREE.VertexColors
				}));

				scene.add(object);
			}

			function add_mesh_data(command) {
				let geom = new THREE.BufferGeometry();
				geom.addAttribute('position', new THREE.BufferAttribute(command.vertices, 3));
				geom.setIndex(new THREE.BufferAttribute(command.faces, 1));
				geom.computeVertexNormals();

                if (command.uvs !== undefined) {
                    geom.addAttribute('uv', new THREE.BufferAttribute(command.uvs, 2));
    				let loader = new THREE.TextureLoader();
    				loader.load(
    				    'HeadTextureMultisense.png',
                        function (texture) {
            				let object = new THREE.Mesh(geom, new THREE.MeshPhongMaterial({
            					color: 0xffffff,
            					reflectivity: 0.5,
                                map: texture
            				}));
                            object.position.set(1.5, 0, 0);
                            object.rotation.set(-Math.PI / 2, 0, 0);
            				scene.add(object);
                        }
                    );
                } else {
                    let object = new THREE.Mesh(geom, new THREE.MeshPhongMaterial({
                        color: 0xffffff,
                        reflectivity: 0.5
                    }));
                    object.position.set(1.5, 0, 0);
                    object.rotation.set(-Math.PI / 2, 0, 0);
                    scene.add(object);
                }

			}

			function handle_setgeometry(command) {
				if (command.type == "pointcloud") {
					add_pointcloud(command);
				} else if (command.type == "mesh_data") {
					add_mesh_data(command);
				} else {
					console.warn("Unhandled geometry:", command.type);
				}
			}

			connection.onmessage = function (raw_data) {
				let data = msgpack.decode(new Uint8Array(raw_data.data));

				for (let cmd of data.setgeometry) {
					handle_setgeometry(cmd);
				}
				// // let data = JSON.parse(raw_data.data);
				// // console.log(data);
				// let geom = new THREE.Geometry();

				// for (let vertdata of data["vertices"]) {
				// 	geom.vertices.push(new THREE.Vector3(vertdata[0], vertdata[1], vertdata[2]));
				// }
				// for (let facedata of data["faces"]) {
				// 	geom.faces.push(new THREE.Face3(facedata[0], facedata[1], facedata[2]));
				// }
				// // geom.vertices.push(new THREE.Vector3(0, 0, 0));
				// // geom.vertices.push(new THREE.Vector3(0, 1, 0));
				// // geom.vertices.push(new THREE.Vector3(0, 1, 1));
				// // geom.faces.push(new THREE.Face3(0, 1, 2));
			};


			// particleLight = new THREE.Mesh( new THREE.SphereBufferGeometry( 0.05, 8, 8 ), new THREE.MeshBasicMaterial( { color: 0xffffff } ) );
			// particleLight.position.set(2, 0, 0);
			// scene.add( particleLight );

			// var point_light = new THREE.PointLight(0xffffff, 2, 800);
			// point_light.position.set(2, 1, 1);
			// scene.add(point_light);
			// particleLight.add(point_light);

			// var loader = new THREE.OBJLoader();
			// loader.load('head_multisense.obj',
			//             function(object) {
			//             	scene.add(object);
			//             },
			//             function (xhr) {
			//             	console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

			// 			},
			// 			// called when loading has errors
			// 			function ( error ) {

			// 				console.log( 'An error happened' );

			// 			}
			// );

			// var geom = new THREE.Geometry();
			// geom.vertices.push(new THREE.Vector3(0, 0, 0));
			// geom.vertices.push(new THREE.Vector3(0, 1, 0));
			// geom.vertices.push(new THREE.Vector3(0, 1, 1));
			// geom.faces.push(new THREE.Face3(0, 1, 2));
			// var object = new THREE.Mesh(geom, new THREE.MeshPhongMaterial({color: 0xffffff, reflectivity: 0.5}));
			// scene.add(object);


            scene.add(new THREE.GridHelper(20, 40));



			camera.position.z = 5;

			var controls = new THREE.OrbitControls(camera);

			function animate() {
				requestAnimationFrame(animate);
				// cube.rotation.x += 0.1;
				// cube.rotation.y += 0.1;
				controls.update();
				renderer.render(scene, camera);
			}
			animate();
		</script>
	</body>
</html>
