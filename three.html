<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>My first three.js app</title>
		<style>
			body { margin: 0;
            }
			canvas {
                width: 100%;
                height: 100%;
                background: -moz-linear-gradient(top,  lightskyblue 0%, midnightblue 100%); /* FF3.6-15 */
                background: -webkit-linear-gradient(top,  lightskyblue 0%,midnightblue 100%); /* Chrome10-25,Safari5.1-6 */
                background: linear-gradient(to bottom,  lightskyblue 0%,midnightblue 100%); /* W3C, IE10+, FF16+, Chrome26+, Opera12+, Safari7+ */
            }


		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/msgpack.min.js"></script>
		<script>
			var scene = new THREE.Scene();
            // scene.background = new THREE.Color('skyblue');
			var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 100);
			var renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);



            class ViewerNode {
                constructor(name) {
                    this.name = name;
                    this.children = {};
                    this.geometry_objects = [];
                    this.object = new THREE.Object3D;
                }

                addChild(name) {
                    let child = new ViewerNode(name, this);
                    this.object.add(child.object);
                    this.children[name] = child;
                    return child;
                }

                getChild(name) {
                    let child = this.children[name]
                    if (child === undefined) {
                        return this.addChild(name);
                    } else {
                        return child;
                    }
                }

                setGeometryObjects(objs) {
                    for (let obj of this.geometry_objects) {
                        this.object.remove(obj);
                    }
                    for (let obj of objs) {
                        this.object.add(obj);
                    }
                    this.geometry_objects = objs;
                }

                getPath(path) {
                    if (path.length > 0) {
                        let child = this.getChild(path[0]);
                        return child.getPath(path.slice(1, path.length + 1));
                    } else {
                        return this;
                    }
                }
            }

            let root = new ViewerNode("TreeViewer")
            scene.add(root.object);
            root.object.rotateX(-Math.PI/2);

            let geom = new THREE.Geometry();
            geom.vertices.push(new THREE.Vector3(0, 0, 0));
            geom.vertices.push(new THREE.Vector3(0, 0.2, 0));
            geom.vertices.push(new THREE.Vector3(0, 0.2, 0.2));
            geom.faces.push(new THREE.Face3(0, 1, 2));
            let object = new THREE.Mesh(geom, new THREE.MeshPhongMaterial({color: 0xffffff, reflectivity: 0.5}));

            root.getPath(["foo", "bar"]).setGeometryObjects([object]);
            root.getPath(["foo"]).object.position.y = 1;
            root.getPath(["foo", "bar"]).object.position.z = 1;

			var geometry = new THREE.BoxGeometry(1, 1, 1);
			var material = new THREE.MeshPhongMaterial({color: 0x00ff00,
				reflectivity: 0.5,
				shininess: Math.pow(2, 10)
			});
			var cube = new THREE.Mesh(geometry, material);
			// scene.add(cube);

			var light = new THREE.DirectionalLight(0xffffff, 0.5);
			light.position.set(5, 5, 10);
			scene.add(light);

			var ambient_light = new THREE.AmbientLight(0xffffff, 0.3);
			scene.add(ambient_light);



			function add_pointcloud(command) {
				let geom = new THREE.BufferGeometry();
				geom.addAttribute('position', new THREE.BufferAttribute(command.points, 3));

				if (command.channels !== undefined) {
					if (command.channels.rgb !== undefined) {
						geom.addAttribute('color', new THREE.BufferAttribute(command.channels.rgb, 3));
					}
				}

				let object = new THREE.Points(geom, new THREE.PointsMaterial({
					size: 0.001,
					vertexColors: THREE.VertexColors
				}));

				root.object.add(object);
			}

			function add_mesh_data(command) {
				let geom = new THREE.BufferGeometry();
				geom.addAttribute('position', new THREE.BufferAttribute(command.vertices, 3));
				geom.setIndex(new THREE.BufferAttribute(command.faces, 1));
				geom.computeVertexNormals();

                if (command.texture !== undefined) {
                    geom.addAttribute('uv', new THREE.BufferAttribute(command.texture.coordinates, 2));

                    let png_bytes = command.texture.png;
                    let blob = new Blob([png_bytes], {type: "image/png"});
                    let pngUrl = URL.createObjectURL(blob);

    				let loader = new THREE.TextureLoader();
    				let texture = loader.load(pngUrl);
    				let object = new THREE.Mesh(geom, new THREE.MeshPhongMaterial({
    					color: 0xffffff,
    					reflectivity: 0.5,
                        map: texture
    				}));
                    object.position.set(1.5, 0, 0.5);
                    // object.rotation.set(-Math.PI / 2, 0, 0);
    				root.object.add(object);
                } else {
                    let object = new THREE.Mesh(geom, new THREE.MeshPhongMaterial({
                        color: 0xffffff,
                        reflectivity: 0.5
                    }));
                    object.position.set(1.5, 0, 0.5);
                    // object.rotation.set(-Math.PI / 2, 0, 0);
                    root.object.add(object);
                }

			}

			function handle_setgeometry(command) {
				if (command.type == "pointcloud") {
					add_pointcloud(command);
				} else if (command.type == "mesh_data") {
					add_mesh_data(command);
				} else {
					console.warn("Unhandled geometry:", command.type);
				}
			}

			function handle_command(message) {
				console.log(message);
				let data = msgpack.decode(new Uint8Array(message.data));

				for (let cmd of data.setgeometry) {
					handle_setgeometry(cmd);
				}
			};

			let clients = {};

			function handle_name_server_message(message) {
				let url = message;
				// let server_port = msgpack.decode(new Uint8Array(message.data));

				// let url = 'ws://127.0.0.1:'.concat(server_port);
				console.log(url);
				if (clients[url] !== undefined) {
					if (clients[url].readyState == 0 || clients[url].readyState == 1) {
						return;
					}
				}
				let connection = new WebSocket(url);
				clients[url] = connection;
				connection.binaryType = "arraybuffer";
				connection.onopen = function () {
					connection.send(msgpack.encode(100000));
				};
				connection.onmessage = handle_command;
				connection.onclose = function (evt) {
					delete clients[url];
				}
				console.log(connection);
			}

			function listen_for_client() {
				var request = new XMLHttpRequest();
				request.onreadystatechange = function() {
					if (request.readyState == 4) {
						if (request.status == 200) {
							console.log(request.response);
							handle_name_server_message(request.response);
						}
						setTimeout(listen_for_client, 1000);
					}
				}
				request.open("GET", "http://127.0.0.1:8765", true);
				request.timeout = 1000;
				request.send();
			}

			listen_for_client();

			// particleLight = new THREE.Mesh( new THREE.SphereBufferGeometry( 0.05, 8, 8 ), new THREE.MeshBasicMaterial( { color: 0xffffff } ) );
			// particleLight.position.set(2, 0, 0);
			// scene.add( particleLight );

			// var point_light = new THREE.PointLight(0xffffff, 2, 800);
			// point_light.position.set(2, 1, 1);
			// scene.add(point_light);
			// particleLight.add(point_light);

			// var loader = new THREE.OBJLoader();
			// loader.load('head_multisense.obj',
			//             function(object) {
			//             	scene.add(object);
			//             },
			//             function (xhr) {
			//             	console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

			// 			},
			// 			// called when loading has errors
			// 			function ( error ) {

			// 				console.log( 'An error happened' );

			// 			}
			// );




            scene.add(new THREE.GridHelper(20, 40));
            // let axes = new THREE.AxesHelper(1);
            // axes.position.set(3, 0, 3);
            // scene.add(axes);

			camera.position.set(3, 1, 0);


			var controls = new THREE.OrbitControls(camera);

			function animate() {
				requestAnimationFrame(animate);
				// cube.rotation.x += 0.1;
				// cube.rotation.y += 0.1;
				controls.update();
				renderer.render(scene, camera);
			}
			animate();
		</script>
	</body>
</html>
