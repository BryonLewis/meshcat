<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>My first three.js app</title>
		<style>
			body { margin: 0;
            }
			canvas {
                width: 100%;
                height: 100%;
                background: -moz-linear-gradient(top,  lightskyblue 0%, midnightblue 100%); /* FF3.6-15 */
                background: -webkit-linear-gradient(top,  lightskyblue 0%,midnightblue 100%); /* Chrome10-25,Safari5.1-6 */
                background: linear-gradient(to bottom,  lightskyblue 0%,midnightblue 100%); /* W3C, IE10+, FF16+, Chrome26+, Opera12+, Safari7+ */
            }


		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script src="js/OrbitControls.js"></script>
        <script src="js/OBJLoader.js"></script>
		<script src="js/msgpack.min.js"></script>
		<script>
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 100);
			var renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

            function create_tree_viewer_root() {
                let viewer_tree = new THREE.Object3D();
                viewer_tree.name = "TreeViewer";
                viewer_tree.rotateX(-Math.PI / 2);
                scene.add(viewer_tree);
                return viewer_tree;
            }

            var viewer_tree = create_tree_viewer_root();
            viewer_tree.add(new THREE.AxesHelper(0.5));

            function find_child(path, root) {
                if (root === undefined) {
                    root = viewer_tree;
                }
                if (path.length > 0) {
                    let child = root.children.find(c => c.name == path[0]);
                    if (child === undefined) {
                        child = new THREE.Object3D();
                        child.name = path[0];
                        root.add(child);
                    }
                    return find_child(path.slice(1, path.length + 1), child);
                } else {
                    return root;
                }
            }

            function set_transform(path, position, quaternion) {
                let child = find_child(path);
                child.position.fromArray(position);
                child.quaternion.fromArray(quaternion);
            }

            function set_property(path, property, value) {
                let obj = find_child(path);
                obj[property] = value;
            }

            function add_object(path, object) {
                find_child(path).add(object);
            }

            function delete_path(path) {
                let parent = find_child(path.slice(0, path.length));
                let child = parent.children.find(c => c.name == object.name);
                if (child !== undefined) {
                    parent.remove(child);
                }
            }

            function handle_command(cmd) {
                if (cmd.type == "set_property") {
                    set_property(cmd.path, cmd.property, cmd.value);
                } else if (cmd.type == "set_transform") {
                    set_transform(cmd.path, cmd.position, cmd.quaternion);
                } else if (cmd.type == "delete") {
                    delete_path(path);
                    if (path.length == 0) {
                        viewer_tree = create_tree_viewer_root();
                    }
                } else if (cmd.type == "add_object") {
                    let loader = new THREE.ObjectLoader();
                    loader.parse(cmd.object, function (obj) {
                        console.log(obj); 
                        obj.geometry.computeVertexNormals();
                        add_object(cmd.path, obj);
                    });
                }
            }

			function handle_command_message(message) {
				let data = msgpack.decode(new Uint8Array(message.data));
                console.log(data);

                for (let cmd of data.commands) {
                    handle_command(cmd);
                }
			};

			let clients = {};

			function handle_name_server_message(message) {
				let url = message;
				if (clients[url] !== undefined) {
					if (clients[url].readyState == 0 || clients[url].readyState == 1) {
						return;
					}
				}
				let connection = new WebSocket(url);
				clients[url] = connection;
				connection.binaryType = "arraybuffer";
				connection.onmessage = handle_command_message;
				connection.onclose = function (evt) {
					delete clients[url];
				}
			}

            handle_name_server_message("ws://127.0.0.1:5005");

			function listen_for_client() {
				var request = new XMLHttpRequest();
				request.onreadystatechange = function() {
					if (request.readyState == 4) {
						if (request.status == 200) {
							handle_name_server_message(request.response);
						}
						setTimeout(listen_for_client, 1000);
					}
				}
				request.open("GET", "http://127.0.0.1:8765", true);
				request.timeout = 1000;
                try {
    				request.send();
                } catch(error) {
                }
			}

			// listen_for_client();

            var light = new THREE.DirectionalLight(0xffffff, 0.5);
            light.position.set(5, 5, 10);
            scene.add(light);

            var ambient_light = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambient_light);

            scene.add(new THREE.GridHelper(20, 40));

			camera.position.set(3, 1, 0);
			var controls = new THREE.OrbitControls(camera);

			function animate() {
				requestAnimationFrame(animate);
				controls.update();
				renderer.render(scene, camera);
			}
			animate();
		</script>
	</body>
</html>
